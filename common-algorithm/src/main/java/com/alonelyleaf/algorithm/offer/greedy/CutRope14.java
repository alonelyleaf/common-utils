package com.alonelyleaf.algorithm.offer.greedy;

/**
 * 剪绳子
 * <p>
 * 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n>1并且m>1，m<=n），每段绳子的长度记为k[1],...,k[m]。
 * 请问k[1]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
 *
 * @author bijl
 * @date 8/16/21
 */
public class CutRope14 {

    /**
     * 贪心算法
     * <p>
     * 尽可能得多剪长度为 3 的绳子，并且不允许有长度为 1 的绳子出现。如果出现了，就从已经切好长度为 3 的绳子中拿出一段与长度为 1 的绳子重新组合，把它们切成两段长度为 2 的绳子。以下为证明过程。
     * <p>
     * 将绳子拆成 1 和 n-1，则 1(n-1)-n=-1<0，即拆开后的乘积一定更小，所以不能出现长度为 1 的绳子。
     * <p>
     * 将绳子拆成 2 和 n-2，则 2(n-2)-n = n-4，在 n>=4 时这样拆开能得到的乘积会比不拆更大。
     * <p>
     * 将绳子拆成 3 和 n-3，则 3(n-3)-n = 2n-9，在 n>=5 时效果更好。
     * <p>
     * 将绳子拆成 4 和 n-4，因为 4=2*2，因此效果和拆成 2 一样。
     * <p>
     * 将绳子拆成 5 和 n-5，因为 5=2+3，而 5<2*3，所以不能出现 5 的绳子，而是尽可能拆成 2 和 3。
     * <p>
     * 将绳子拆成 6 和 n-6，因为 6=3+3，而 6<3*3，所以不能出现 6 的绳子，而是拆成 3 和 3。这里 6 同样可以拆成 6=2+2+2，但是 3(n - 3) - 2(n - 2) = n - 5 >= 0，在 n>=5 的情况下将绳子拆成 3 比拆成 2 效果更好。
     * <p>
     * 继续拆成更大的绳子可以发现都比拆成 2 和 3 的效果更差，因此我们只考虑将绳子拆成 2 和 3，并且优先拆成 3，当拆到绳子长度 n 等于 4 时，也就是出现 3+1，此时只能拆成 2+2。
     */
    public int cutRope(int n) {
        if (n < 2) {
            return 0;
        }

        if (n == 2) {
            return 1;
        }

        if (n == 3) {
            return 2;
        }

        int timesOf3 = n / 3;
        // 如果按3分割后，还剩下1，则从长度为3的里边拿出一个，将剩余的1加进去变成4在进行分割
        if (n - timesOf3 * 3 == 1) {
            timesOf3--;
        }
        int timesOf2 = (n - timesOf3 * 3) / 2;

        return (int) (Math.pow(3, timesOf3) * Math.pow(2, timesOf2));
    }


    /**
     * 动态规划
     * <p>
     * 1.建立数组，记录位置对应长度的最大乘积
     * 2.从绳子从短到长，逐渐计算其对应最大乘积，每当有一段绳子，则可以从小到大进行分割对比，
     *
     * @param n
     * @return
     */
    public int cutRope2(int n) {

        // 结果数组，对应位置长度的最大乘积
        int[] dp = new int[n + 1];
        dp[1] = 1;

        for (int i = 2; i <= n; i++) {

            // i 为当前绳子长度，从1进行分割对比
            for (int j = 1; j < i; j++) {
                // 对比 上次分割结果，左段最大结果与右端乘积，取较大值
                // 这里假设 i-j = r，则在遍历过程中，j走到r时与原有j时结果应该一致，即 1*3=3*1
                dp[i] = Math.max(dp[i], Math.max(j * (i - j), dp[j] * (i - j)));
            }
        }
        return dp[n];
    }

    public static void main(String[] args) {

        CutRope14 cutRope14 = new CutRope14();
        System.out.println(cutRope14.cutRope2(8));
    }
}
